// Если include имеет аргумент в знаках <>, то файл будет искаться в 
// стандартных директориях. Если аргумент указать в "", то файл будет искаться
// в директории проекта (или в укзанной директории, если путь абсолютный)
#include <stdio.h>
#include <stdlib.h>
// пример #include "my.h" или #include "../my.h" или #include "D:\\my.h"

//----------------------------------------------------------------------
// не выдает ошибки при встрече несуществующей инструкции
// #pragma инструкция

//----------------------------------------------------------------------
// #flag обозначает перевод имени переменной в строковую константу
// Если есть код 
// int val = 100; TRACE(val);
// получится printf("val" "=%d\n", val); // две строки розделенные пробелом
// приведут к их конкатенации, и получится printf("val=%d\n", val);
#define TRACE(flag) printf(#flag "=%d\n", flag)

// В подстановке аргументы берутся в скобки, чтобы они не теряли 
// логической нагрузки, если в качестве аргумента передадутся выражения
#define CUBE(a) (a)*(a)*(a)
#define MAX(a,b) ( (a) > (b) ? (a) : (b) )

//----------------------------------------------------------------------
// Директивы условной компиляции
/*
#if          константное выражеие    // проверка истинности выражения
#ifdef       идентификатор           // определен ли идентификатор
#ifndef      идентификатор           // не определен ли идентификатор
#elif        констанотное выражение  // проверка истинности выражения
#else
#endif
*/

//----------------------------------------------------------------------

// #error сообщение // прекращение компиляции с выводом сообщения:
// fatal error:  __FILE__ __LINE__ сообщение

//----------------------------------------------------------------------
// следующий блок позволяет включать или отключать вывод отладочной инфы
#define MYDEBUG

// Если MYDEBUG не определена, то все упоминания в коде о выводе отладочной
// информации нужно заменить на пустую строку, иначе, на выражение вывода инфы
#ifndef MYDEBUG
#define DEBUG(v1,v2)
#else
#define DEBUG(v1,v2) printf(#v1 "=%d\t" #v2 "=%f",v1,v2)
#endif
//----------------------------------------------------------------------

//----------------------------------------------------------------------
//Защита header файла student.h от повторной загрузки
#ifndef STUDENT_H
#define STUDENT_H
// code
#endif
//----------------------------------------------------------------------

int main(int argc, char *argv[])
{
  
  const int n = 5; // колчество этажей
  const int m = 3; // количество подъездов
  const int k = 2; // количество квартир на этаже
  int p;           // номер квартиры (вводится пользователем)
  int rn, rm;      // ответ пользователю (этаж и подъезд соотвественно)
  
  do {
      printf("Enter flat number (%d - %d): ", 1, m*n);
      fflush(stdin); // очищаем буфер клавиатуры (stdin)
  } while (scanf("%d", &p) != 1 && printf("A number is required!\n")
               || p <= 0 && printf("A number must be > 0\n") 
               || n*m*k < p  && printf("A number can't be > %d!\n", m*n)
          );
  
  /*
  старая и тупая версия вычислений
  rm = p%(n*k) == 0 ? p/(n*k) : p/(n*k)+1;
  rn = p%(n*k) == 0 ? n : (p%(n*k))%k == 0 ? (p%(n*k))/k : (p%(n*k))/k+1 ;
  printf("Floor = %d and pod = %d\n", rn, rm);
  */
  
  /*
  формула вычисления квартиры исходя из значений этажа и подьезда где 
  на каждом этаже только одна квартира (модель двумерного массива памяти - 
  - все данные разбиты на строки (подьезды), в каждой из которых имеются 
  столбцы (этажи). Если на каждом этаже по несколько квартир - тогда это 
  модель трехмерного массива).
  Номер квартиры вычисляется за такой формулой:
        p = n*(rm-1)+rn // (rm-1) - сколько нужно подьездов пройти
  Но такая формула имеет дефект. Верная формула будет иметь следующий вид:
        p-1 = n*(rm-1)+(rn+1)
  Отсуюда, подъезд и этаж вычисляется за следующими формулами:
  */
        rm = (p-1)/n+1;
        rn = (p-1)%n+1;
  
  printf("Floor = %d and pod = %d\n", rn, rm);
  
  system("PAUSE");	
  return 0;
}
