// Массивы

#include <stdio.h>
#include <stdlib.h>

#define BUFSIZE 10

int main(int argc, char *argv[])
{
    const s = 5;
    int a[s];// определение размера по константе
    int b[BUFSIZE]; // определение размера по дефайновой константе
    
    // сразу определение значений
    int c[BUFSIZE] = {0,15,33}; 

    // так как размер массива не указан, то компилятор сосчитает количество 
    // указанных значений, и это количество автоматом присвоит массиву
    int c1[] = {0,15,33}; 
    
    // законный способ инициализации массива нулями (первый задается явно, а 
    // так как остальных нету, то компилятор неявно присваивает им нули всегда.
    // Без этого там будет мусор)
    int d[BUFSIZE] = {0}; 
    
    // инициализация символьного массива (признак конца строки - нульбайт \n)
    char s1[] = {'H','e','l','l','o','\n'};
    
    // инициализация символьного массива - краткая запись
    char s2[] = "Hello";
    
    // Обьявление многомерного массива (и как бы нету, но можно обьявить массив
    // массивов)
    int m[3][4];

    // Инициализация многомерного массива (полная)
    int m1[3][4] = { {-5,12,3,6}, {7,5,33,55}, {-11,-44,42,7} };

    // Инициализация многомерного массива, размер первого массива (строк) 
    // вычисляется автоматом компилятором (укладывает по порядку все значения)
    int m2[][4] = { -5,12,3,6,7,5,33,55,-11,-44,42,7 };

    // Инициализация многомерного массива (не полная)
    // первые столбики - нечетные, вторые - четные, а остальные - нули
    int m3[3][4] = { {1,2}, {3,4}, {5,6} };

    // Инициализация многомерного массива (не полная)
    // Укладка идет по порядку, остальные добиваются нулями
    int m4[3][4] = { {1,2}, {3,4}, {5,6} };
    
    lab2_2();
    
    system("PAUSE");	
    return 0;
}

// Является ли число простым
int lab2_1()
{
    int x, i;
    printf("Enter x: ");
    scanf("%d", &x);
    for (i = 2; x%i != 0; i++);
    i == x && printf("Yes\n") || printf("No\n");
}

// Найти n простых чисел
int lab2_2()
{
    int a[20] = {2};
    int n, i, j, k; // k - количество найденных чисел
    
    printf("Enter n: ");
    scanf("%d", &n);
    
    for (k = 1, i = 3; n > k ; i += 2) {
        for (j = 3; i % j != 0; j++) ;
        if (i == j) a[k++] = i;
    }
    for (i = 0; i < n; i++)
        printf("a[%d] = %d\n", i, a[i]);
}


// Здесь линейный поиск идет перебором последовательно с двумя условиями
int lab1_1()
{
    int a[] = {5, 9, 6, 3, 5, 7, 1, 9, 2, 4, 0};
    // Вычисление длины массива путем деления его размера на размер одного ел.
    const int n = sizeof a / sizeof a[0];
    int i, x;
    
    // Печать массива
    for (i=0; i<n; i++)
        printf("%d, ", a[i]);
    printf("\b\b \n"); // возврат на 2 позиции назад и поверх запятой - пробел
    printf("\n");
    
    // личейный поиск (v1)
    printf("Enter value:");
    scanf("%d", &x);
    for (i = 0; i < n && a[i] != x; i++) ;
    i < n && printf("a[%d] = %d\n", i+1, x) || printf("Not found\n");
}

// Здесь линейный поиск идет перебором последовательно с ОДНИМ! условием
// Задействован "метод барьера(шлагбаума)", когда в конце массива резервируется
// место для искомого значения, таким образом, проверки выхода за пределы 
// массива можно избежать, ведь последнее значение с искомым будет совпадать
int lab1_2()
{
    int a[] = {5, 9, 6, 3, 5, 7, 1, 9, 2, 4, 0};
    // Вычисление длины массива путем деления его размера на размер одного ел.
    const int n = sizeof a / sizeof a[0];
    int i, x;
    
    // Печать массива
    for (i=0; i<n; i++)
        printf("%d, ", a[i]);
    printf("\b\b \n"); // возврат на 2 позиции назад и поверх запятой - пробел
    printf("\n");
    
    // личейный поиск (v1)
    printf("Enter value:");
    scanf("%d", &x);
    a[n-1] = x; // Ставим барьер (шлагбаум) на зарезервированное место массива
    for (i = 0; a[i] != x; i++) ; // поиск только по одному условию
    i < n-1 && printf("a[%d] = %d\n", i+1, x) || printf("Not found\n");
}
